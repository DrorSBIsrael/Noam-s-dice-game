const updateTimer = async (newTimer) => {
            if (gameRef.current) {
              await gameRef.current.child('turnTimer').set(newTimer);
            }
          };<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משחק הקוביות של נועם</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes diceRoll {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            25% { transform: rotateX(90deg) rotateY(90deg); }
            50% { transform: rotateX(180deg) rotateY(180deg); }
            75% { transform: rotateX(270deg) rotateY(270deg); }
            100% { transform: rotateX(360deg) rotateY(360deg); }
        }
        
        .dice-roll {
            animation: diceRoll 0.1s linear infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
        }
        
        .player-glow {
            animation: glow 1s ease-in-out infinite;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .game-table {
                height: 300px !important;
                max-width: 350px !important;
            }
            .player-avatar {
                width: 60px !important;
                height: 60px !important;
                font-size: 24px !important;
            }
            .dice-main {
                width: 48px !important;
                height: 48px !important;
                font-size: 24px !important;
            }
            .player-dice {
                width: 24px !important;
                height: 24px !important;
                font-size: 12px !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Firebase Configuration
const firebaseConfig = {
  apiKey: "AIzaSyAgWTlNnhRHQ_iGt10EgFuxkib-Z-ifa7s",
  authDomain: "noam-s-dice-game.firebaseapp.com",
  databaseURL: "https://noam-s-dice-game-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "noam-s-dice-game",
  storageBucket: "noam-s-dice-game.firebasestorage.app",
  messagingSenderId: "504625659348",
  appId: "1:504625659348:web:718a1b6b6317bf45cdea41",
  measurementId: "G-H0P3KWLM1P"
};

        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const database = firebase.database();

        const { useState, useEffect, useRef } = React;

        // Simple SVG icons
        const VolumeIcon = ({ enabled }) => (
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
            {enabled && <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>}
            {!enabled && <line x1="23" y1="9" x2="17" y2="15"></line>}
            {!enabled && <line x1="17" y1="9" x2="23" y2="15"></line>}
          </svg>
        );

        const RotateIcon = () => (
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M1 4v6h6"></path>
            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
          </svg>
        );

        const DiceGame = () => {
          // Local state
          const [screen, setScreen] = useState('welcome');
          const [playerName, setPlayerName] = useState('');
          const [gameId, setGameId] = useState('');
          const [playerId, setPlayerId] = useState('');
          const [soundEnabled, setSoundEnabled] = useState(true);
          const [isRolling, setIsRolling] = useState(false);
          const [diceResults, setDiceResults] = useState([]);
          
          // Game state from Firebase
          const [gameData, setGameData] = useState(null);
          const [players, setPlayers] = useState([]);
          const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
          const [gameRound, setGameRound] = useState(1);
          const [turnTimer, setTurnTimer] = useState(10);
          const [gameSettings, setGameSettings] = useState({ playerCount: 2, gameType: 1 });
          
          const audioRef = useRef(null);
          const gameRef = useRef(null);

          // Generate unique IDs
          const generateId = () => Math.random().toString(36).substr(2, 9);

          // Firebase listeners
          useEffect(() => {
            if (gameId && gameRef.current) {
              const unsubscribe = gameRef.current.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                  setGameData(data);
                  setPlayers(Object.values(data.players || {}));
                  setCurrentPlayerIndex(data.currentPlayerIndex || 0);
                  setGameRound(data.gameRound || 1);
                  setTurnTimer(data.turnTimer || 10);
                  setGameSettings(data.settings || { playerCount: 2, gameType: 1 });
                  
                  // Update screen based on game state
                  if (data.status === 'waiting' && Object.keys(data.players || {}).length < data.settings.playerCount) {
                    setScreen('waiting');
                  } else if (data.status === 'playing') {
                    setScreen('game');
                  } else if (data.status === 'finished') {
                    setScreen('gameOver');
                  }
                }
              });

              return () => gameRef.current.off('value', unsubscribe);
            }
          }, [gameId]);

          // Timer effect
          useEffect(() => {
            if (screen === 'game' && gameData && gameData.status === 'playing') {
              const interval = setInterval(() => {
                if (turnTimer > 0 && !isRolling && players[currentPlayerIndex]?.id === playerId) {
                  updateTimer(turnTimer - 1);
                  if (turnTimer <= 1) {
                    rollDice();
                  }
                }
              }, 1000);
              return () => clearInterval(interval);
            }
          }, [screen, turnTimer, isRolling, currentPlayerIndex, playerId]);

          // Sound effects
          const playDiceSound = () => {
            if (soundEnabled && audioRef.current) {
              audioRef.current.currentTime = 0;
              audioRef.current.play().catch(e => console.log('Sound play failed:', e));
            }
          };

          // Firebase functions
          const createGame = async (settings, hostName) => {
            const newGameId = generateId();
            const newPlayerId = generateId();
            
            const gameData = {
              id: newGameId,
              status: 'waiting',
              settings: settings,
              players: {
                [newPlayerId]: {
                  id: newPlayerId,
                  name: hostName,
                  totalScore: 0,
                  eliminated: false,
                  lastRoll: null,
                  isHost: true,
                  joinedAt: Date.now()
                }
              },
              currentPlayerIndex: 0,
              gameRound: 1,
              turnTimer: 10,
              createdAt: Date.now()
            };

            await database.ref(`games/${newGameId}`).set(gameData);
            setGameId(newGameId);
            setPlayerId(newPlayerId);
            gameRef.current = database.ref(`games/${newGameId}`);
            setScreen('waiting');
          };

          const resetGame = async () => {
            if (!gameRef.current) return;
            
            // Reset all players
            for (const player of players) {
              await gameRef.current.child(`players/${player.id}`).update({
                totalScore: 0,
                eliminated: false,
                lastRoll: null
              });
            }
            
            // Reset game state
            await gameRef.current.update({
              currentPlayerIndex: 0,
              gameRound: 1,
              turnTimer: 10,
              status: 'playing'
            });
          };

          const deleteGame = async () => {
            if (gameRef.current) {
              await gameRef.current.remove();
              setScreen('welcome');
              setGameId('');
              setPlayerId('');
              setGameData(null);
              setPlayers([]);
              gameRef.current = null;
            }
          };

          const joinGame = async (gameIdToJoin, playerNameToJoin) => {
            const newPlayerId = generateId();
            
            try {
              const gameSnapshot = await database.ref(`games/${gameIdToJoin}`).once('value');
              const existingGame = gameSnapshot.val();
              
              if (!existingGame) {
                alert('שולחן לא נמצא! בדוק את הקוד.');
                return;
              }
              
              if (existingGame.status !== 'waiting') {
                alert('המשחק כבר התחיל!');
                return;
              }
              
              const playerCount = Object.keys(existingGame.players || {}).length;
              if (playerCount >= existingGame.settings.playerCount) {
                alert('השולחן מלא!');
                return;
              }

              await database.ref(`games/${gameIdToJoin}/players/${newPlayerId}`).set({
                id: newPlayerId,
                name: playerNameToJoin,
                totalScore: 0,
                eliminated: false,
                lastRoll: null,
                isHost: false,
                joinedAt: Date.now()
              });

              // If table is full, start game
              if (playerCount + 1 >= existingGame.settings.playerCount) {
                await database.ref(`games/${gameIdToJoin}/status`).set('playing');
              }

              setGameId(gameIdToJoin);
              setPlayerId(newPlayerId);
              gameRef.current = database.ref(`games/${gameIdToJoin}`);
              
            } catch (error) {
              alert('שגיאה בהתחברות לשולחן');
            }
          };

          const resetGame = async () => {
            if (!gameRef.current) return;
            
            // Reset all players
            for (const player of players) {
              await gameRef.current.child(`players/${player.id}`).update({
                totalScore: 0,
                eliminated: false,
                lastRoll: null
              });
            }
            
            // Reset game state
            await gameRef.current.update({
              currentPlayerIndex: 0,
              gameRound: 1,
              turnTimer: 10,
              status: 'playing'
            });
          };

          const rollDice = async () => {
            if (isRolling || !gameRef.current || players[currentPlayerIndex]?.id !== playerId) return;
            
            setIsRolling(true);
            playDiceSound();
            
            let rollCount = 0;
            const maxRolls = 20;
            
            const rollInterval = setInterval(() => {
              rollCount++;
              setDiceResults(Array.from({length: 5}, () => Math.floor(Math.random() * 6) + 1));
              
              if (rollCount >= maxRolls) {
                clearInterval(rollInterval);
                
                setTimeout(async () => {
                  const finalResults = Array.from({length: 5}, () => Math.floor(Math.random() * 6) + 1);
                  setDiceResults(finalResults);
                  
                  const score = calculateScore(finalResults);
                  const combination = getScoreCombination(finalResults);
                  
                  // Update player's roll in Firebase
                  await gameRef.current.child(`players/${playerId}`).update({
                    totalScore: (players.find(p => p.id === playerId)?.totalScore || 0) + score,
                    lastRoll: {
                      dice: finalResults,
                      score: score,
                      combination: combination
                    }
                  });
                  
                  setIsRolling(false);
                  
                  setTimeout(() => {
                    nextTurn();
                  }, 1500);
                }, 300);
              }
            }, 100);
          };

          const nextTurn = async () => {
            if (!gameRef.current) return;

            const activePlayers = players.filter(p => !p.eliminated);
            let nextIndex = (currentPlayerIndex + 1) % players.length;
            
            // Skip eliminated players
            while (players[nextIndex] && players[nextIndex].eliminated) {
              nextIndex = (nextIndex + 1) % players.length;
            }
            
            // Check if round is complete
            const firstActiveIndex = players.findIndex(p => !p.eliminated);
            if (nextIndex === firstActiveIndex && activePlayers.every(p => p.lastRoll)) {
              
              if (gameSettings.gameType === 1) {
                // Elimination mode
                if (activePlayers.length > 1) {
                  const lowestScore = Math.min(...activePlayers.map(p => p.totalScore));
                  
                  // Eliminate lowest scorers
                  for (const player of activePlayers) {
                    if (player.totalScore === lowestScore) {
                      await gameRef.current.child(`players/${player.id}/eliminated`).set(true);
                    }
                  }
                  
                  const remainingPlayers = activePlayers.filter(p => p.totalScore !== lowestScore);
                  if (remainingPlayers.length === 1) {
                    await gameRef.current.child('status').set('finished');
                    return;
                  }
                  
                  // Clear last rolls and advance round
                  for (const player of players) {
                    await gameRef.current.child(`players/${player.id}/lastRoll`).set(null);
                  }
                  
                  await gameRef.current.child('gameRound').set(gameRound + 1);
                  nextIndex = players.findIndex(p => !p.eliminated);
                }
              } else if (gameSettings.gameType === 2) {
                // 5 round mode
                if (gameRound >= 5) {
                  await gameRef.current.child('status').set('finished');
                  return;
                } else {
                  // Clear last rolls and advance round
                  for (const player of activePlayers) {
                    await gameRef.current.child(`players/${player.id}/lastRoll`).set(null);
                  }
                  
                  await gameRef.current.child('gameRound').set(gameRound + 1);
                  nextIndex = 0;
                }
              }
            }
            
            await gameRef.current.child('currentPlayerIndex').set(nextIndex);
            await gameRef.current.child('turnTimer').set(10);
          };

          // Calculate score and combinations (same as before)
          const calculateScore = (dice) => {
            const counts = {};
            dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
            const values = Object.values(counts).sort((a,b) => b-a);
            const sortedDice = [...dice].sort((a,b) => a-b);
            
            if (values[0] === 5) return 5000 * dice[0];
            if (sortedDice.join('') === '12345' || sortedDice.join('') === '23456') return 10000;
            if (values[0] === 4) {
              const num = Object.keys(counts).find(k => counts[k] === 4);
              return 1500 * parseInt(num);
            }
            if (values[0] === 3 && values[1] === 2) {
              const threeNum = Object.keys(counts).find(k => counts[k] === 3);
              return 500 * parseInt(threeNum);
            }
            if (values[0] === 3) {
              const threeNum = Object.keys(counts).find(k => counts[k] === 3);
              return 250 * parseInt(threeNum);
            }
            if (values[0] === 2 && values[1] === 2) {
              const pairs = Object.keys(counts).filter(k => counts[k] === 2).map(Number);
              return 100 * Math.max(...pairs);
            }
            if (values[0] === 2) {
              const pairNum = Object.keys(counts).find(k => counts[k] === 2);
              return 10 * parseInt(pairNum);
            }
            return dice.reduce((sum, d) => sum + d, 0);
          };

          const getScoreCombination = (dice) => {
            const counts = {};
            dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
            const values = Object.values(counts).sort((a,b) => b-a);
            const sortedDice = [...dice].sort((a,b) => a-b);
            
            if (values[0] === 5) return '5 זהות!';
            if (sortedDice.join('') === '12345' || sortedDice.join('') === '23456') return 'רצף!';
            if (values[0] === 4) return '4 זהות';
            if (values[0] === 3 && values[1] === 2) return 'פול האוס';
            if (values[0] === 3) return '3 זהות';
            if (values[0] === 2 && values[1] === 2) return 'זוג כפול';
            if (values[0] === 2) return 'זוג';
            return 'ללא קומבינציה';
          };

          const resetGame = async () => {
            if (!gameRef.current) return;
            
            // Reset all players
            for (const player of players) {
              await gameRef.current.child(`players/${player.id}`).update({
                totalScore: 0,
                eliminated: false,
                lastRoll: null
              });
            }
            
            // Reset game state
            await gameRef.current.update({
              currentPlayerIndex: 0,
              gameRound: 1,
              turnTimer: 10,
              status: 'playing'
            });
          };

          const getPlayerPosition = (index, total) => {
            const angle = (index * 360) / Math.min(total, 10);
            const radius = window.innerWidth < 768 ? 35 : 45;
            const x = 50 + radius * Math.cos((angle - 90) * Math.PI / 180);
            const y = 50 + radius * Math.sin((angle - 90) * Math.PI / 180);
            return { x: `${x}%`, y: `${y}%` };
          };

          const avatarEmojis = [
            '🧑‍💼', '👩‍🦰', '🧑‍🎨', '👨‍🏫', '👩‍⚕️', 
            '🧑‍🚀', '👩‍🎤', '👨‍🍳', '👩‍🔬', '🧑‍🎮'
          ];

          const avatarGradients = [
            'bg-gradient-to-br from-red-400 to-red-600',
            'bg-gradient-to-br from-blue-400 to-blue-600', 
            'bg-gradient-to-br from-green-400 to-green-600',
            'bg-gradient-to-br from-yellow-400 to-orange-500',
            'bg-gradient-to-br from-purple-400 to-purple-600',
            'bg-gradient-to-br from-pink-400 to-pink-600',
            'bg-gradient-to-br from-indigo-400 to-indigo-600',
            'bg-gradient-to-br from-orange-400 to-red-500',
            'bg-gradient-to-br from-teal-400 to-teal-600',
            'bg-gradient-to-br from-gray-400 to-gray-600'
          ];

          return (
            <div className="min-h-screen bg-gradient-to-br from-green-800 to-green-900 flex items-center justify-center p-2 sm:p-4" dir="rtl">
              <audio 
                ref={audioRef} 
                preload="auto"
                src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEUATR2y/LPfOcFKnHM8dmINgkRbL3tqW8aBDNEn9/us2QZNB9B"
              />

              {/* Welcome Screen */}
              {screen === 'welcome' && (
                <div className="text-center bg-white rounded-xl p-6 sm:p-8 shadow-2xl max-w-md w-full mx-2">
                  <h1 className="text-3xl sm:text-4xl font-bold text-green-800 mb-4 sm:mb-6">🎲</h1>
                  <h2 className="text-2xl sm:text-3xl font-bold text-gray-800 mb-6 sm:mb-8">משחק הקוביות של נועם</h2>
                  
                  <div className="space-y-4">
                    <input 
                      type="text"
                      placeholder="הכנס את שמך"
                      value={playerName}
                      onChange={(e) => setPlayerName(e.target.value)}
                      className="w-full p-3 border rounded-lg text-center text-lg"
                    />
                    
                    <button 
                      onClick={() => setScreen('setup')}
                      disabled={!playerName.trim()}
                      className="bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white font-bold py-3 px-6 rounded-lg text-lg sm:text-xl w-full transition-colors"
                    >
                      צור שולחן חדש
                    </button>
                    
                    <div className="text-gray-500 font-bold">או</div>
                    
                    <input 
                      type="text"
                      placeholder="קוד שולחן (6 תווים)"
                      value={gameId}
                      onChange={(e) => setGameId(e.target.value.toLowerCase())}
                      className="w-full p-3 border rounded-lg text-center text-lg font-mono"
                      maxLength={9}
                    />
                    
                    <button 
                      onClick={() => joinGame(gameId, playerName)}
                      disabled={!playerName.trim() || !gameId.trim()}
                      className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white font-bold py-3 px-6 rounded-lg text-lg w-full transition-colors"
                    >
                      הצטרף לשולחן
                    </button>
                  </div>
                </div>
              )}

              {/* Setup Screen */}
              {screen === 'setup' && (
                <div className="text-center bg-white rounded-xl p-6 sm:p-8 shadow-2xl max-w-md w-full mx-2">
                  <h2 className="text-xl sm:text-2xl font-bold text-gray-800 mb-4 sm:mb-6">הגדרת שולחן חדש</h2>
                  
                  <div className="space-y-4 sm:space-y-6">
                    <div>
                      <label className="block text-gray-700 font-bold mb-2">כמות שחקנים</label>
                      <select 
                        value={gameSettings.playerCount}
                        onChange={(e) => setGameSettings({...gameSettings, playerCount: parseInt(e.target.value)})}
                        className="w-full p-3 border rounded-lg text-center text-lg"
                      >
                        {[2,3,4,5,6,7,8,9].map(n => (
                          <option key={n} value={n}>{n} שחקנים</option>
                        ))}
                      </select>
                    </div>
                    
                    <div>
                      <label className="block text-gray-700 font-bold mb-2">סוג משחק</label>
                      <select 
                        value={gameSettings.gameType}
                        onChange={(e) => setGameSettings({...gameSettings, gameType: parseInt(e.target.value)})}
                        className="w-full p-3 border rounded-lg text-center text-lg"
                      >
                        <option value={1}>שחקן מול שחקן (עם הדחה)</option>
                        <option value={2}>5 סיבובים (ללא הדחה)</option>
                      </select>
                    </div>
                    
                    <button 
                      onClick={() => createGame(gameSettings, playerName)}
                      className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg w-full transition-colors"
                    >
                      צור שולחן
                    </button>
                    
                    <button 
                      onClick={() => setScreen('welcome')}
                      className="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg w-full transition-colors"
                    >
                      חזור
                    </button>
                  </div>
                </div>
              )}

              {/* Waiting Screen */}
              {screen === 'waiting' && (
                <div className="text-center bg-white rounded-xl p-6 sm:p-8 shadow-2xl max-w-md w-full mx-2">
                  <h2 className="text-xl sm:text-2xl font-bold text-gray-800 mb-4 sm:mb-6">ממתין לשחקנים</h2>
                  
                  <div className="bg-gray-100 p-4 rounded-lg mb-4">
                    <p className="text-sm text-gray-600 mb-2">קוד השולחן:</p>
                    <p className="text-2xl font-mono font-bold text-green-600">{gameId}</p>
                    <p className="text-xs text-gray-500 mt-2">שתף את הקוד עם שחקנים אחרים</p>
                  </div>
                  
                  <div className="mb-6">
                    <p className="text-lg font-bold mb-2">
                      שחקנים: {players.length}/{gameSettings.playerCount}
                    </p>
                    <div className="space-y-2">
                      {players.map((player, index) => (
                        <div key={player.id} className="flex items-center justify-center gap-2">
                          <span className="text-2xl">{avatarEmojis[index]}</span>
                          <span className="font-medium">{player.name}</span>
                          {player.isHost && <span className="text-xs bg-yellow-200 px-2 py-1 rounded">מארח</span>}
                        </div>
                      ))}
                    </div>
                  </div>
                  
                  <div className="text-sm text-gray-600 mb-4">
                    ממתין לעוד {gameSettings.playerCount - players.length} שחקנים...
                  </div>
                  
                  {/* Reset button for host in waiting screen */}
                  {players.find(p => p.id === playerId)?.isHost && (
                    <button
                      onClick={() => {
                        if (confirm('האם אתה בטוח שברצונך לאפס את השולחן?')) {
                          deleteGame();
                        }
                      }}
                      className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors"
                    >
                      🗑️ מחק שולחן
                    </button>
                  )}
                </div>
              )}

              {/* Game Screen */}
              {screen === 'game' && (
                <div className="w-full max-w-6xl mx-auto px-2">
                  <div className="absolute top-2 left-2 z-10">
                    <button
                      onClick={() => setSoundEnabled(!soundEnabled)}
                      className="bg-white rounded-full p-2 sm:p-3 shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <VolumeIcon enabled={soundEnabled} />
                    </button>
                  </div>

                  {/* Reset button for host */}
                  {players.find(p => p.id === playerId)?.isHost && (
                    <div className="absolute top-2 right-2 z-10">
                      <button
                        onClick={() => {
                          if (confirm('האם אתה בטוח שברצונך לאפס את המשחק?')) {
                            resetGame();
                          }
                        }}
                        className="bg-red-500 hover:bg-red-600 text-white rounded-full p-2 sm:p-3 shadow-lg hover:shadow-xl transition-all text-xs sm:text-sm font-bold"
                        title="איפוס משחק"
                      >
                        🔄
                      </button>
                    </div>
                  )}

                  <div className="text-center text-white mb-4 sm:mb-6 relative">
                    <h2 className="text-xl sm:text-2xl font-bold">
                      סיבוב {gameRound}
                      {gameSettings.gameType === 2 && <span className="text-yellow-300"> / 5</span>}
                    </h2>
                    <p className="text-sm sm:text-base">תור: {players[currentPlayerIndex]?.name}</p>
                    {!isRolling && players[currentPlayerIndex]?.id === playerId && (
                      <div className={`absolute left-4 sm:left-8 top-1/2 transform -translate-y-1/2 text-sm sm:text-lg font-bold ${turnTimer <= 3 ? 'text-red-400 animate-pulse' : 'text-yellow-300'}`}>
                        ⏰ {turnTimer}
                      </div>
                    )}
                  </div>

                  <div className={`relative w-full game-table bg-green-600 rounded-full border-4 sm:border-8 border-yellow-600 shadow-2xl mx-auto`} style={{height: window.innerWidth < 768 ? '300px' : '384px', maxWidth: window.innerWidth < 768 ? '350px' : '64rem'}}>
                    {players.map((player, index) => {
                      const pos = getPlayerPosition(index, players.length);
                      const isCurrentPlayer = index === currentPlayerIndex;
                      return (
                        <div
                          key={player.id}
                          className={`absolute transform -translate-x-1/2 -translate-y-1/2 text-center ${
                            player.eliminated ? 'opacity-30 grayscale' : ''
                          } ${isCurrentPlayer ? 'scale-110 z-10' : ''} transition-all duration-500`}
                          style={{ left: pos.x, top: pos.y }}
                        >
                          <div className={`player-avatar w-16 h-16 sm:w-24 sm:h-24 ${avatarGradients[index]} rounded-full flex items-center justify-center text-2xl sm:text-4xl mb-1 sm:mb-2 shadow-lg border-2 sm:border-4 border-white ${
                            isCurrentPlayer ? 'ring-4 sm:ring-8 ring-yellow-400 ring-opacity-80 player-glow transform scale-110' : 'ring-1 sm:ring-2 ring-white ring-opacity-50'
                          } transition-all duration-500 hover:scale-105`}>
                            {avatarEmojis[index]}
                          </div>
                          <div className={`text-white text-xs sm:text-base font-bold ${isCurrentPlayer ? 'text-yellow-300' : ''}`}>
                            {player.name}
                          </div>
                          <div className="text-yellow-300 text-xs sm:text-base font-bold">{player.totalScore} נק'</div>
                          {player.lastRoll && (
                            <>
                              <div className="flex gap-1 justify-center mb-1 sm:mb-2 -mt-8 sm:-mt-12">
                                {player.lastRoll.dice.map((dice, diceIndex) => (
                                  <div
                                    key={diceIndex}
                                    className="player-dice w-6 h-6 sm:w-8 sm:h-8 bg-white rounded text-black text-xs sm:text-base flex items-center justify-center font-bold border border-gray-400 shadow-lg transform hover:scale-110 transition-transform duration-200"
                                  >
                                    {dice}
                                  </div>
                                ))}
                              </div>
                              <div className="text-xs sm:text-sm text-gray-200 mt-1">
                                {player.lastRoll.combination}<br/>
                                +{player.lastRoll.score}
                              </div>
                            </>
                          )}
                        </div>
                      );
                    })}

                    <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
                      {diceResults.length > 0 && (
                        <div className="flex gap-2 sm:gap-3 mb-4 sm:mb-6 justify-center">
                          {diceResults.map((dice, index) => (
                            <div
                              key={index}
                              className={`dice-main w-12 h-12 sm:w-16 sm:h-16 bg-white rounded-lg sm:rounded-xl flex items-center justify-center text-xl sm:text-3xl font-bold border-2 sm:border-3 border-gray-400 shadow-2xl transform transition-all duration-300 ${
                                isRolling ? 'dice-roll scale-110' : 'hover:scale-105'
                              }`}
                              style={{
                                animationDelay: isRolling ? `${index * 0.1}s` : '0s',
                                background: isRolling ? 'linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57)' : 'white',
                                backgroundSize: isRolling ? '300% 300%' : 'auto',
                                animation: isRolling ? 'gradient 0.5s ease infinite, spin 0.3s linear infinite' : 'none'
                              }}
                            >
                              <span className={isRolling ? 'animate-bounce' : ''}>{dice}</span>
                            </div>
                          ))}
                        </div>
                      )}
                      
                      {!isRolling && players[currentPlayerIndex]?.id === playerId && (
                        <button
                          onClick={rollDice}
                          className="bg-gradient-to-r from-red-500 to-red-700 hover:from-red-600 hover:to-red-800 text-white font-bold py-2 px-4 sm:py-4 sm:px-8 rounded-lg sm:rounded-xl shadow-lg transition-all duration-300 transform hover:scale-105 hover:shadow-2xl text-sm sm:text-base"
                        >
                          <span className="text-lg sm:text-2xl mr-2">🎲</span>
                          זרוק קוביות
                        </button>
                      )}
                      
                      {!isRolling && players[currentPlayerIndex]?.id !== playerId && (
                        <div className="text-white font-bold text-sm sm:text-xl bg-black bg-opacity-50 rounded-lg px-4 py-2 sm:px-6 sm:py-3">
                          תור של {players[currentPlayerIndex]?.name}
                        </div>
                      )}
                      
                      {isRolling && (
                        <div className="text-white font-bold text-sm sm:text-xl animate-pulse bg-black bg-opacity-50 rounded-lg px-4 py-2 sm:px-6 sm:py-3">
                          <span className="animate-bounce inline-block">🎲</span>
                          <span className="mx-2">זורק קוביות...</span>
                          <span className="animate-bounce inline-block" style={{animationDelay: '0.2s'}}>🎲</span>
                        </div>
                      )}
                    </div>
                  </div>

                  {players[currentPlayerIndex]?.lastRoll && (
                    <div className="text-center text-white mt-4 sm:mt-6 bg-black bg-opacity-50 rounded-lg p-3 sm:p-4 max-w-sm sm:max-w-md mx-auto">
                      <h3 className="text-lg sm:text-xl font-bold">{players[currentPlayerIndex].lastRoll.combination}</h3>
                      <p className="text-sm sm:text-lg">+{players[currentPlayerIndex].lastRoll.score} נקודות</p>
                      <p className="text-xs sm:text-sm opacity-75">סה"כ: {players[currentPlayerIndex].totalScore} נקודות</p>
                    </div>
                  )}
                </div>
              )}

              {/* Game Over Screen */}
              {screen === 'gameOver' && (
                <div className="text-center bg-white rounded-xl p-6 sm:p-8 shadow-2xl max-w-md w-full mx-2">
                  <h1 className="text-4xl sm:text-6xl mb-4">🏆</h1>
                  <h2 className="text-2xl sm:text-3xl font-bold text-yellow-600 mb-4">
                    {gameSettings.gameType === 1 
                      ? players.find(p => !p.eliminated)?.name 
                      : (() => {
                          const activePlayers = players.filter(p => !p.eliminated);
                          const highestScore = Math.max(...activePlayers.map(p => p.totalScore));
                          const winners = activePlayers.filter(p => p.totalScore === highestScore);
                          return winners.length === 1 ? winners[0].name : `${winners.length} מנצחים!`;
                        })()
                    }
                  </h2>
                  <p className="text-lg sm:text-xl text-gray-700 mb-2">מנצח!</p>
                  <p className="text-base sm:text-lg text-gray-600 mb-6">
                    ניקוד סופי: {gameSettings.gameType === 1 
                      ? players.find(p => !p.eliminated)?.totalScore 
                      : Math.max(...players.filter(p => !p.eliminated).map(p => p.totalScore))
                    } נקודות
                  </p>
                  
                  <div className="space-y-3">
                    <button
                      onClick={() => {
                        setScreen('welcome');
                        setGameId('');
                        setPlayerId('');
                        setPlayerName('');
                        setGameData(null);
                        setPlayers([]);
                        if (gameRef.current) {
                          gameRef.current.off();
                          gameRef.current = null;
                        }
                      }}
                      className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg w-full transition-colors flex items-center justify-center gap-2 text-sm sm:text-base"
                    >
                      <RotateIcon />
                      משחק חדש
                    </button>
                    
                    <div className="text-xs sm:text-sm text-gray-500">
                      קוד השולחן: {gameId}
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        };

        ReactDOM.render(React.createElement(DiceGame), document.getElementById('root'));
    </script>
</body>
</html>
